pipeline {
    agent any

    environment {
        TERRAFORM_DIR     = "Terraform_vSphere/root"
        ANSIBLE_DIR       = "Ansible_vSphere"
        ESXI_PASSWORD     = credentials('ESXI_PASSWORD')
        ANSIBLE_VM_CREDENTIALS = credentials('ANSIBLE_VM_CREDENTIALS')
        GRAFANA_PASS      = credentials('GRAFANA_ADMIN_PASSWORD')
        
        // OPTIMIZATION: Ansible performance environment variables
        ANSIBLE_HOST_KEY_CHECKING = 'False'
        ANSIBLE_SSH_PIPELINING = 'True'
        ANSIBLE_GATHERING = 'smart'
        ANSIBLE_FACT_CACHING = 'memory'
        ANSIBLE_CALLBACK_WHITELIST = 'timer'
        ANSIBLE_STRATEGY = 'free'
        ANSIBLE_FORCE_HANDLERS = 'True'
        ANSIBLE_TIMEOUT = '30'
        ANSIBLE_CONNECT_TIMEOUT = '10'
        ANSIBLE_COMMAND_TIMEOUT = '30'
    }

    triggers {
        githubPush()
    }

    stages {
        stage('Checkout Code') {
            steps {
                checkout scm
            }
        }

        stage('Validate Environment') {
            steps {
                sh '''
                    echo "=== Checking Tools ==="
                    which terraform || { echo "ERROR: terraform not found"; exit 1; }
                    terraform version
                    which ansible || { echo "ERROR: ansible not found"; exit 1; }
                    ansible --version
                    which jq || { echo "ERROR: jq not found"; exit 1; }
                    jq --version
                    which ovftool || { echo "ERROR: ovftool not found"; exit 1; }
                    ovftool --version
                '''
            }
        }

        stage('Init Terraform') {
            steps {
                dir("${TERRAFORM_DIR}") {
                    sh 'terraform init'
                }
            }
        }

        stage('Plan Terraform') {
            steps {
                dir("${TERRAFORM_DIR}") {
                    sh '''
                        terraform plan \
                          -var="esxi_password=${ESXI_PASSWORD}" \
                          -out=tfplan
                    '''
                }
            }
        }

        stage('Apply Terraform') {
            steps {
                dir("${TERRAFORM_DIR}") {
                    sh 'terraform apply -auto-approve tfplan'
                }
            }
        }

        stage('Export Terraform Output') {
            steps {
                dir("${TERRAFORM_DIR}") {
                    sh '''
                        TF_CLI_ARGS="-no-color" terraform output -json > raw_output.json
                        jq . raw_output.json > terraform-output.json
                        mv terraform-output.json "${WORKSPACE}/${ANSIBLE_DIR}/"
                    '''
                }
            }
        }

        stage('Generate Ansible Inventory') {
            steps {
                sh '''
                    chmod +x "${WORKSPACE}/${ANSIBLE_DIR}/generated_inventory.sh"
                    "${WORKSPACE}/${ANSIBLE_DIR}/generated_inventory.sh"
                    cat "${WORKSPACE}/${ANSIBLE_DIR}/inventory.ini"
                '''
            }
        }

        // OPTIMIZED Ansible execution with performance tuning
        stage('Ansible Base Setup - OPTIMIZED') {
            steps {
                dir("${ANSIBLE_DIR}") {
                    withCredentials([
                        usernamePassword(credentialsId: 'ANSIBLE_VM_CREDENTIALS', usernameVariable: 'ANSIBLE_USER', passwordVariable: 'ANSIBLE_PASS')
                    ]) {
                        sh '''
                            echo "=== Optimized Ansible Configuration ==="
                            
                            # Create optimized ansible.cfg
                            cat > ansible.cfg << 'EOF'
[defaults]
host_key_checking = False
timeout = 30
gathering = smart
fact_caching = memory
callback_whitelist = timer, profile_tasks
strategy = free
forks = 10
poll_interval = 1
ssh_args = -C -o ControlMaster=auto -o ControlPersist=60s -o ControlPath=/tmp/ansible-ssh-%h-%p-%r -o StrictHostKeyChecking=no
pipelining = True
accelerate_port = 5099
accelerate_timeout = 30
accelerate_connect_timeout = 5.0

[ssh_connection]
ssh_args = -C -o ControlMaster=auto -o ControlPersist=60s -o StrictHostKeyChecking=no
pipelining = True
control_path = /tmp/ansible-ssh-%%h-%%p-%%r
EOF

                            echo "=== Running OPTIMIZED Base Configuration ==="
                            time ansible-playbook -i inventory.ini playbook-setup.yml \\
                              --extra-vars "ansible_ssh_user=${ANSIBLE_USER}" \\
                              --extra-vars "ansible_ssh_pass=${ANSIBLE_PASS}" \\
                              --extra-vars "ansible_become_pass=${ANSIBLE_PASS}" \\
                              --extra-vars "ansible_serial=5" \\
                              --forks=10 \\
                              --strategy=free \\
                              --become
                        '''
                    }
                }
            }
        }

        stage('Ansible Monitoring Stack - OPTIMIZED') {
            steps {
                dir("${ANSIBLE_DIR}") {
                    withCredentials([
                        usernamePassword(credentialsId: 'ANSIBLE_VM_CREDENTIALS', usernameVariable: 'ANSIBLE_USER', passwordVariable: 'ANSIBLE_PASS'),
                        string(credentialsId: 'GRAFANA_ADMIN_PASSWORD', variable: 'GRAFANA_PASS')
                    ]) {
                        sh '''
                            echo "=== Running OPTIMIZED Monitoring Stack ==="
                            time ansible-playbook -i inventory.ini playbook-monitoring.yml \\
                              --extra-vars "ansible_ssh_user=${ANSIBLE_USER}" \\
                              --extra-vars "ansible_ssh_pass=${ANSIBLE_PASS}" \\
                              --extra-vars "grafana_admin_password=${GRAFANA_PASS}" \\
                              --extra-vars "ansible_serial=5" \\
                              --forks=10 \\
                              --strategy=free \\
                              --become
                        '''
                    }
                }
            }
        }
    }

    post {
        success {
            echo '✅ Deployment successful!'
        }
        failure {
            echo '❌ Deployment failed!'
        }
        always {
            cleanWs()
        }
    }
}