/**
 * COMPLETE JENKINS PIPELINE FOR VSPHERE AUTOMATION PROJECT
 *
 * Automates the full infrastructure lifecycle:
 * 1. Optional Packer template creation
 * 2. Terraform provisioning of infrastructure
 * 3. Ansible configuration management
 * 4. Post-deployment health checks
 */

pipeline {
    // Define where the pipeline will run (any available agent)
    agent any

    /**
     * ENVIRONMENT VARIABLES
     * Centralize configuration and credentials for consistent usage across stages.
     */
    environment {
        TERRAFORM_VERSION = '1.6.0'
        ANSIBLE_VERSION = '2.15.0'
        PACKER_VERSION = '1.10.0'

        // Secure vSphere credentials stored in Jenkins Credentials Manager
        VSPHERE_USER = credentials('VSPHERE_USER')
        VSPHERE_PASSWORD = credentials('VSPHERE_PASSWORD')
        VSPHERE_SERVER = 'vcenter.example.com'

        PACKER_CACHE_DIR = '/var/lib/jenkins/packer_cache'

        // Terraform remote state management
        TF_STATE_BUCKET = 'terraform-state-bucket'
        TF_STATE_KEY = 'vsphere-automation/terraform.tfstate'

        // Disable SSH host key checking for Ansible to avoid manual confirmation prompts
        ANSIBLE_HOST_KEY_CHECKING = 'False'
    }

    /**
     * PIPELINE PARAMETERS
     * Allow runtime customization of Terraform actions, Packer builds, and deployment environment.
     */
    parameters {
        choice(name: 'ACTION', choices: ['plan', 'apply', 'destroy'], description: 'Terraform operation to execute.')
        booleanParam(name: 'BUILD_TEMPLATE', defaultValue: false, description: 'Trigger Packer VM template build.')
        choice(name: 'ENVIRONMENT', choices: ['dev', 'staging', 'prod'], description: 'Deployment environment.')
    }

    /**
     * PIPELINE STAGES
     * Structured automation steps for source checkout, tool setup, infrastructure provisioning, configuration, and validation.
     */
    stages {
        stage('Checkout Code') {
            steps {
                script {
                    cleanWs() // Clean workspace before build
                    git branch: 'main', url: 'https://github.com/MedSarih/vSphere_Automation_Project.git'
                    env.BUILD_TIMESTAMP = sh(script: 'date +%Y%m%d-%H%M%S', returnStdout: true).trim()
                    env.BUILD_TAG = "build-${env.BUILD_NUMBER}-${env.BUILD_TIMESTAMP}"
                }
            }
        }

        stage('Setup Tools') {
            steps {
                sh '''
                # Install/update required CLI tools and verify versions
                sudo apt-get update
                sudo apt-get install -y jq
                terraform version
                ansible --version
                packer version
                jq --version
                '''
            }
        }

        stage('Packer Template Build') {
            when { expression { params.BUILD_TEMPLATE } }
            steps {
                withCredentials([usernamePassword(credentialsId: 'vsphere-credentials', usernameVariable: 'PACKER_VSPHERE_USER', passwordVariable: 'PACKER_VSPHERE_PASSWORD')]) {
                    dir('packer') {
                        sh '''
                        # Generate dynamic Packer variables and validate template
                        cat > packer-vars.json << EOF
                        {
                          "vcenter_server": "${VSPHERE_SERVER}",
                          "username": "${PACKER_VSPHERE_USER}",
                          "password": "${PACKER_VSPHERE_PASSWORD}",
                          "datacenter": "Datacenter1",
                          "cluster": "Cluster1",
                          "datastore": "datastore1",
                          "network": "VM Network",
                          "template_name": "ubuntu-template-${BUILD_TAG}",
                          "iso_url": "http://releases.ubuntu.com/22.04/ubuntu-22.04.3-live-server-amd64.iso",
                          "iso_checksum": "84aeaf7823c8c614ae6045a50a022871914d7a565107e251d86870837c1c33f4"
                        }
                        EOF
                        packer validate -var-file=packer-vars.json ubuntu-template.pkr.hcl
                        packer build -var-file=packer-vars.json ubuntu-template.pkr.hcl
                        '''
                    }
                }
            }
            post {
                success { echo "Packer template build succeeded." }
                failure { 
                    echo "Packer template build failed."
                    slackSend channel: '#jenkins-notifications', message: "Packer build failed in ${env.JOB_NAME} #${env.BUILD_NUMBER}"
                }
            }
        }

        stage('Terraform Init') {
            steps {
                dir('terraform') {
                    sh 'terraform init -upgrade'
                }
            }
        }

        stage('Terraform Validation') {
            steps {
                dir('terraform') {
                    sh '''
                    terraform validate
                    terraform fmt -check
                    '''
                }
            }
        }

        stage('Terraform Plan') {
            steps {
                withCredentials([usernamePassword(credentialsId: 'vsphere-credentials', usernameVariable: 'TF_VAR_vsphere_user', passwordVariable: 'TF_VAR_vsphere_password')]) {
                    dir('terraform') {
                        sh '''
                        export TF_VAR_vsphere_server="${VSPHERE_SERVER}"
                        export TF_VAR_template_name="ubuntu-template-${BUILD_TAG}"
                        terraform plan -out=tfplan -var="vsphere_server=${VSPHERE_SERVER}"
                        '''
                    }
                }
            }
            post {
                always {
                    dir('terraform') {
                        sh 'terraform show -json tfplan > terraform-plan.json'
                        archiveArtifacts artifacts: 'terraform/terraform-plan.json', allowEmptyArchive: true
                    }
                }
            }
        }

        stage('Terraform Apply') {
            when { expression { params.ACTION in ['apply', 'destroy'] } }
            steps {
                timeout(time: 30, unit: 'MINUTES') {
                    withCredentials([usernamePassword(credentialsId: 'vsphere-credentials', usernameVariable: 'TF_VAR_vsphere_user', passwordVariable: 'TF_VAR_vsphere_password')]) {
                        dir('terraform') {
                            sh '''
                            export TF_VAR_vsphere_server="${VSPHERE_SERVER}"
                            export TF_VAR_template_name="ubuntu-template-${BUILD_TAG}"

                            if [ "${ACTION}" = "destroy" ]; then
                              echo "Destroying all resources after 10 second delay..."
                              sleep 10
                              terraform destroy -auto-approve -var="vsphere_server=${VSPHERE_SERVER}"
                            else
                              terraform apply -auto-approve tfplan
                            fi

                            terraform output -json > terraform-outputs.json
                            '''
                        }
                    }
                }
            }
            post {
                success {
                    dir('terraform') {
                        sh 'terraform output -json > terraform-outputs.json'
                        archiveArtifacts artifacts: 'terraform/terraform-outputs.json', allowEmptyArchive: true
                    }
                }
                failure {
                    echo "Terraform apply failed."
                    slackSend channel: '#jenkins-notifications', message: "Terraform apply failed in ${env.JOB_NAME} #${env.BUILD_NUMBER}"
                }
            }
        }

        stage('Generate Ansible Inventory') {
            when { expression { params.ACTION == 'apply' } }
            steps {
                dir('terraform') {
                    sh '''
                    chmod +x ../scripts/generate_inventory.sh
                    ../scripts/generate_inventory.sh
                    cat inventory.ini
                    cp inventory.ini ../ansible/
                    '''
                }
            }
            post {
                success {
                    dir('ansible') {
                        sh 'cat inventory.ini'
                        archiveArtifacts artifacts: 'ansible/inventory.ini', allowEmptyArchive: true
                    }
                }
            }
        }

        stage('Ansible Base Configuration') {
            when { expression { params.ACTION == 'apply' } }
            steps {
                timeout(time: 20, unit: 'MINUTES') {
                    dir('ansible') {
                        sh '''
                        sleep 60  # Allow VMs to boot and SSH to become available
                        ansible-playbook -i inventory.ini main-vm-config.yml --private-key ~/.ssh/id_rsa -u ubuntu --extra-vars "ansible_ssh_common_args='-o StrictHostKeyChecking=no'"
                        '''
                    }
                }
            }
        }

        stage('Ansible Monitoring Setup') {
            when { expression { params.ACTION == 'apply' } }
            steps {
                timeout(time: 15, unit: 'MINUTES') {
                    dir('ansible') {
                        sh '''
                        ansible-playbook -i inventory.ini monitoring-setup.yml --private-key ~/.ssh/id_rsa -u ubuntu --extra-vars "ansible_ssh_common_args='-o StrictHostKeyChecking=no' grafana_admin_password=YourSecurePassword123"
                        '''
                    }
                }
            }
        }

        stage('Health Check') {
            when { expression { params.ACTION == 'apply' } }
            steps {
                dir('ansible') {
                    sh '''
                    ansible monitoring_servers -i inventory.ini -m uri -a "url=http://localhost:9090/status return_content=yes" -u ubuntu
                    ansible monitoring_servers -i inventory.ini -m uri -a "url=http://localhost:3000/api/health return_content=yes" -u ubuntu
                    ansible all -i inventory.ini -m service -a "name=ssh state=started" -u ubuntu --become
                    '''
                }
            }
        }
    }

    /**
     * POST-BUILD ACTIONS
     * Notifications and workspace cleanup on success, failure, or always.
     */
    post {
        success {
            script {
                def duration = ((System.currentTimeMillis() - currentBuild.startTimeInMillis) / 1000 / 60).toInteger()
                echo "Pipeline completed successfully in ${duration} minutes."
                slackSend channel: '#jenkins-notifications', message: "✅ ${env.JOB_NAME} #${env.BUILD_NUMBER} completed in ${duration} min"
            }
        }
        failure {
            script {
                echo "Pipeline failed. Review logs for details."
                slackSend channel: '#jenkins-notifications', message: "❌ ${env.JOB_NAME} #${env.BUILD_NUMBER} failed - <${env.BUILD_URL}|View Logs>"
            }
        }
        cleanup {
            cleanWs()
        }
    }
}
